#!/bin/bash
#Module containing functions called from cylon package
#Functions: pacmanFunc, pkglistFunc,updateFunc,checkPacFunc and rssFunc

#FUNCTION HEADER
# NAME : PacmanFunc
# DESCRIPTION : Pacman package manager options
# PROCESS : See options array      
#NOTE gnu-netcat is neeeded for the first option.      
function PacmanFunc 
{
			clear
			#Pacman package manager options:
			msgFunc line
			msgFunc green "Pacman package manager. Number of packages installed = $(pacman -Q | wc -l) "
			msgFunc line
			msgFunc blue "Pacman package manager options:-"
			local choicePMVar=""
			local pacStingVar=""
			local optionsPMArr=("Check Network and check for pacman updates (no download)" "pacman -Syu Upgrade packages" \
			"pacman -Si Display extensive information about a given package" "pacman -S Install Package" \
			"pacman -Ss Search for packages in the database" \
			"pacman -Rs Remove Package" "pacman -Qs Search for already installed packages" \
			"pacman -Qi  Display extensive information for locally installed packages" "pacman -Ql  List all files owned by a given package." \
			"pacman -Qkk Verify packages" "paccache -r Prune older packages from cache, Keep last 3"\
			"Remove all packages not required as dependencies (orphans)" "Make a copy of package lists"  \
			"Back-up the local pacman database" "Arch Linux News Rss feed" "$(checkPacFunc arch-audit  NOMES)" \
			"pactree options" "Edit pacman config file" "Return to main menu")
			select choicePMVar in "${optionsPMArr[@]}"
			do
			case "$choicePMVar" in
					"${optionsPMArr[0]}")
					msgFunc green "Pacman updates ready:-.... "
					#check gnu-netcat is installed
					#check network connectivity if good get updates numbers from arch
						checkNetFunc "archlinux.org"
						msgFunc norm   "Number of Pacman updates ready...> $(checkupdates | wc -l)"
						checkupdates
					;;
					"${optionsPMArr[1]}") #update pacman
						msgFunc green "Update system with Pacman."
						sudo pacman -Syu
					;;
					"${optionsPMArr[2]}") #pacman -Si Display extensive information about a given package
						msgFunc green "Display information  for Package."
						msgFunc norm "Please enter package name"
						read -r pacStingVar
						pacman -Si "$pacStingVar"
					;;
					"${optionsPMArr[3]}") #pacman -S Install Package
						msgFunc green "Install package."
						msgFunc norm "Please enter package name"
						read -r pacStingVar
						sudo pacman -S "$pacStingVar"
					;;
					"${optionsPMArr[4]}")   #pacman -Ss Search Repos for Package
						msgFunc green "Search for packages in the database."
						msgFunc norm "Please enter package name"
						read -r pacStingVar
						pacman -Ss "$pacStingVar"
					;;
					"${optionsPMArr[5]}") #pacman -Rs Delete Package
						msgFunc green "Remove Package."
						msgFunc norm "Please enter package name"
						read -r pacStingVar
						sudo pacman -Rs "$pacStingVar"
					;;
					"${optionsPMArr[6]}")   #pacman -Qs Search for already installed packages
						msgFunc green "Search for already installed packages."
						msgFunc norm "Please enter package name"
						read -r pacStingVar
						pacman -Qs "$pacStingVar"
					;;
					"${optionsPMArr[7]}") #pacman -Qi Display extensive information about a given package(local install)
						msgFunc green "Display information  for Package."
						msgFunc norm "Please enter package name"
						read -r pacStingVar
						pacman -Qi "$pacStingVar"
					;;
					"${optionsPMArr[8]}") #pacman -Ql  List all files owned by a given package.
						msgFunc green "List all files owned by a given package."
						msgFunc norm "Please enter package name"
						read -r pacStingVar
						pacman -Ql "$pacStingVar"
					;;
					"${optionsPMArr[9]}") #pacman -Qkk  Verify all packages
						makeDirFunc "-PKGINFO"
						msgFunc green "Verify  packages pacman -Qkk"
						msgFunc norm "Yes for just one package, no for all [y/n] ?"
						if msgFunc yesno
						then # yes
							msgFunc norm "Please enter package name"
							read -r pacStingVar
							pacman -Qkk "$pacStingVar" > pkgver
						else
							pacman -Qkk > pkgverall
						fi
					;;
					"${optionsPMArr[10]}")  msgFunc green  "Prune older packages from cache, paccache -r Keeps last 3"
					#The paccache script, deletes all cached  package 
						#regardless of whether they're installed or not, 
						#except for the most recent 3, 
							sudo paccache -r
					;;
					
					"${optionsPMArr[11]}")   #delete orphans
						msgFunc green "Delete orphans!"
						#Remove all packages not required as dependencies (orphans)
						sudo pacman -Rns "$(pacman -Qtdq)"
					;;

					"${optionsPMArr[12]}")
						msgFunc green "Make copy of package lists"
						pkglistFunc
					;;
					"${optionsPMArr[13]}") #backup the pacman database
						msgFunc green "Back-up the pacman database to :"
						makeDirFunc "-BACKUPPACMAN"
						tar -v -cjf pacman_database.tar.bz2 /var/lib/pacman/local
					;;

					
					"${optionsPMArr[14]}") #Arch Linux News Rss feed
						RssFunc
						;;
						
					"${optionsPMArr[15]}") #run arch audit
						msgFunc green "Running arch-audit program :"
						local archauditVar=""
						#check archaudit is installed
						if ! checkPacFunc arch-audit
							then
							msgFunc anykey 
							return
						fi
						msgFunc norm "Press [A] for full output: or other options> -q=quiet, -u=upgradable, -uq."
						read -r archauditVar
						if [ "$archauditVar" = "A" ] 
							then
							arch-audit
							else
							 arch-audit "$archauditVar"
						fi 
						archauditVar=
						;;
					
						"${optionsPMArr[16]}") #pactree
									local pactreeVar=""
									msgFunc green "pactree options"
									msgFunc norm "List a dependency tree of a package: pactree"
									msgFunc norm "Show packages that depend on the named package: pactree -r"
									msgFunc norm "press [A] for pactree or [r] for pactree -r. [A/r]"
									read -r pactreeVar
									if [ "$pactreeVar" != "r" ]
									then
										msgFunc norm "Please enter package name"
										read -r pacStingVar
										pactree "$pacStingVar"
									else
										msgFunc norm "Please enter package name"
										read -r pacStingVar
										pactree -r "$pacStingVar"
									fi
						;;
						"${optionsPMArr[17]}") #edit pacman conf file
							msgFunc green "Edit Pacman.conf file."
							sudo nano  /etc/pacman.conf
						;;
							
						*)  #exit  
							msgFunc green "Done!"	
							clear
							return
						;;
			esac
			break
			done
			msgFunc green "Done!"	
			msgFunc anykey 
}

#FUNCTION HEADER
# NAME :            RssFunc
# DESCRIPTION :     Display 4 Arch Linux News Rss feed
function RssFunc 
{
				#Display 4 Arch Linux News Rss feed
				msgFunc green "Arch Linux News Rss feed"
				# Set countVar to be the number of latest news to fetch
				newsVar=$(echo -e $(curl --silent https://www.archlinux.org/feeds/news/  | awk ' NR == 1 {countVar = 4; while (countVar) {print;getline; if($0 ~ /<\/item>/) countVar=countVar-1} ; sub(/<\/item>.*/,"</item>") ;print}'))
				#  THE RSS PARSER Remove some tags 
				newsVar=$(echo -e "$newsVar" | \
				awk '{
				sub(/<lastBuildDate[^>]*>([^>]*>)/,"");sub(/<language[^>]*>([^>]*>)/,"");sub(/<title[^>]*>([^>]*>)/,"");sub(/<link[^>]*>([^>]*>)/,""); 
				while (sub(/<guid[^>]*>([^>]*>)/,"")); 
				while (sub(/<dc:creator[^>]*>([^>]*>)/,""));
				while (sub(/<description[^>]*>([^>]*>)/,"")); print }' | \
				sed -e ':a;N;$!ba;s/\n/ /g')
			    echo -e "$(echo -e "$newsVar" | \
				sed -e 's/&amp;/\&/g
				s/&lt;\|&#60;/</g
				s/&gt;\|&#62;/>/g
				s/<\/a>/£/g
				s/href\=\"/§/g
				s/<title>/\\n\\n :: \\e[01;31m/g; s/<\/title>/\\e[00m ::/g
				s/<link>/\\n [ \\e[01;36m/g; s/<\/link>/\\e[00m ]\\n/g
				s/<p\( [^>]*\)\?>\|<br\s*\/\?>/\n/g
				s/<b\( [^>]*\)\?>\|<strong\( [^>]*\)\?>/\\e[01;30m/g; s/<\/b>\|<\/strong>/\\e[00;37m/g
				s/<i\( [^>]*\)\?>\|<em\( [^>]*\)\?>/\\e[41;37m/g; s/<\/i>\|<\/em>/\\e[00;37m/g
				s/<u\( [^>]*\)\?>/\\e[4;37m/g; s/<\/u>/\\e[00;37m/g
				s/<code\( [^>]*\)\?>/\\e[00m/g; s/<\/code>/\\e[00;37m/g
				s/<a[^§|t]*§\([^\"]*\)\"[^>]*>\([^£]*\)[^£]*£/\\e[01;31m\2\\e[00;37m \\e[01;34m[\\e[00;37m \\e[04m\1\\e[00;37m\\e[01;34m ]\\e[00;37m/g
				s/<li\( [^>]*\)\?>/\n \\e[01;34m*\\e[00;37m /g
				s/<!\[CDATA\[\|\]\]>//g
				s/\|>\s*<//g
				s/ *<[^>]\+> */ /g
				s/[<>£§]//g')"    
				#end
}

#FUNCTION HEADER
# NAME :            pkglistFunc
#INPUT $1 Backup if called from backup do not create directory
# DESCRIPTION :creates a copy of packages list see below.
#OUTPUT seven files see below
#NOTE called from pacman pacur cower and backup  functions 
 # shellcheck disable=SC2120
function pkglistFunc
{
				msgFunc green "Making a copy of package lists "
				#check for input if Backup called from backup do not create dir
				if [ "$1" != "Backup" ]
				then
					makeDirFunc "-PKGINFO"
				fi
				
				msgFunc green "All installed packages: pkglistQ.txt" 
				pacman -Q | wc -l
				pacman -Q  > pkglistQ.txt
				
				msgFunc green "All native packages: pkglistQn.txt" 
				pacman -Qn | wc -l
				pacman -Qn > pkglistQn.txt
				
				msgFunc green "All explicitly installed packages: pkglistQe.txt" 
				pacman -Qe | wc -l
				pacman -Qe  > pkglistQe.txt
				
				msgFunc green "All explicitly installed native packages that are"
				msgFunc green "not direct or optional dependencies: pkglistQgent.txt"
				pacman -Qqent | wc -l
				pacman -Qqent > pkglistQqent.txt
				
				msgFunc green "All foreign installed packages: pkglistQm.txt"
				pacman -Qm | wc -l
				pacman -Qm > pkglistQm.txt
				
				msgFunc green "All foreign explicitly installed packages: pkglistQme.txt"
				pacman -Qme | wc -l
				pacman -Qme > pkglistQme.txt
				
				msgFunc green "All explicitly installed packages not in base nor base-devel with size"
				msgFunc green "and description: pkglistNonBase.txt"
				expac -H M "%011m\t%-20n\t%10d" $(comm -23 <(pacman -Qqen | sort) <(pacman -Qqg base base-devel | sort))\
				| sort -hr > pkglistNonBase.txt 
				wc -l < pkglistNonBase.txt 
				
				msgFunc green "All installed packages sorted by size: pkglistSize.txt"
				expac -H M '%m\t%n' | sort -hr > pkglistSize.txt
				msgFunc norm "Largest package :$(head -1 pkglistSize.txt)"
				
				msgFunc green "All installed packages sorted by install date: pkglistDate.txt"
				expac --timefmt='%Y-%m-%d %T' '%l\t%n' | sort -hr > pkglistDate.txt
				msgFunc norm "Newest package :$(head -1 pkglistDate.txt)"
				
				msgFunc green "All .pacnew and .pacsave files :  pacNewSaveFiles.txt"
				find / -regextype posix-extended -regex ".+\.pac(new|save)" 2> /dev/null > pacNewSaveFiles.txt
				wc -l < pacNewSaveFiles.txt 
}

##FUNCTION HEADER
# NAME :  updatefunc
# DESCRIPTION: called from checkinputfunc or main menu.
function updateFunc
{
		clear
		#check if arch-audit package  installed
		if ! checkPacFunc arch-audit
		then
			msgFunc anykey 
			clear
		return
		fi
		#check if pacaur package  installed
		if ! checkPacFunc pacaur
		then
			msgFunc anykey 
			clear
		return
		fi
		clear
		msgFunc green "Accessing archlinux.org Network Database...."
		msgFunc line
		RssFunc
		msgFunc anykey
		msgFunc line
		msgFunc green "Arch-audit upgradable vulnerable packages"
		arch-audit -u
		msgFunc norm " "
		msgFunc green "Arch-audit vulnerable packages"
		arch-audit -q
		msgFunc anykey
		msgFunc line
		msgFunc green "Number of Pacman updates ready ..> $(checkupdates | wc -l)"	
		checkupdates
		msgFunc line
		msgFunc green "Number of updates available for installed AUR packages ..> $(cower -u | wc -l)"
		cower -uc
		msgFunc line
		#display update options
		local choiceUfVar=""
		msgFunc blue "Update options:-"
		local optionsPArr=("pacman -Syu Update Main only" \
"pacaur -Syu Update  All" "pacaur -u Update AUR only " "No Update exit")
				select choiceUfVar in "${optionsPArr[@]}"
				do
				case "$choiceUfVar" in  
				"${optionsPArr[0]}")
					sudo pacman -Syu
				;;
				
				"${optionsPArr[1]}")
					pacaur -Syu
				;;
				
				"${optionsPArr[2]}")
					pacaur -u
				;;
				
				*)msgFunc norm " "
				;;
				esac
				break
				done
		msgFunc green "Done!"
		msgFunc anykey
}

#FUNCTION HEADER
# NAME : checkPacFunc
#DESCRIPTION : Checks if package installed 
#PROCESS: check if package(passed $1) installed if NOMES passed 
#as $2 goto menu display mode and appends passed $3
#NOMES =no message
# INPUTS : $1(package $2(NOMES flag) or (append text))
#OUTPUTS: returns 0 for installed 1 for not installed    
function checkPacFunc
{
	local pacVar=""
	pacVar=$(pacman -Qqs "$1")
	if [ -n "$pacVar" ]
	then #installed
		#if text input is NOMES skip install good message
		if [ "$2" = "NOMES" ] 
		then 
			printf '%s' "$1"
		else
			printf '%s\n' "$1 is Installed $2"
		fi
		return 0
	else #not installed
		#if text input is NOMES skip install bad message
		if [ "$2" = "NOMES" ] 
		then
			printf '%s' "$1 n/a"
		else
			printf '%s\n' "${RED}$1 is Not installed${NORMAL} $2"
		fi
		return 1
	fi 
}
